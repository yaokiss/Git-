# C#面向对象（强类型）语言

## 第一阶段 C#

### 第一部分：面向过程。1—6天

1. C#语言简洁：
   
   C#发展史,C# 是由 Anders Hejlsberg(安德斯·海尔斯伯格) 和他的团队在 .Net 框架开发期间开发的。
   
   人机交互，控制台指令，环境变量的配置，使用csc.exe编译器对源文件进行编译运行		

1. Main方法的作用：程序的唯一入口。
		
1. 数据类型：

	  值类型（数值型（整型、浮点型）、字符（char、单引号）、布尔bool（true（真,1）、false（假,0））、结构体(struct)、枚举(enum)）,栈
	
    引用类型(数组、字符串、类、接口、委托),堆	

1. 常量与变量：
	
    变量的本质(内存中的一块存储区域),里面的数据是不断变化的,注意定义变量时的细节，
	
    常量 两种含义：(1)客观存在的数据。(2)使用const关键字定义常量，不会再后边程序的运行中数值不会被改变。

1. 类型转换：在C#中存在两种类型转换
	
   自动类型提升（从低往高转），系统底层自动完成的，程序员自身不需要参加，从低类型（子类）自动转换为高类型（父类）
	
   强制类型转换（从高往低转），需要通过代码完成，(目标类型)变量，使用as关键字
	
    **注意：类型转化还可以用于引用类型**

1. 运算符：
  
    算数运算符：+ - * / % ++ --
			
   赋值运算符：= += -= *= /=
		
   比较运算符: > < >= <= == != 最后结果都是bool值
		
   逻辑运算符： & && | || ^ ! 逻辑运算符用来连接两个值是bool类型的表达式
			
   三元运算符： ? :  (条件表达式) ? 数据1 : 数据2
			
   位运算符：  & | ^ ~ >> << 都是用来进行位(二进制)运算

1. 语句(流程控制)：分支结构和循环结构
			
      分支结构：if语句和switch语句
					
      if语句包含3种格式，每种格式都有其使用的场景
			
      switch格式比较复杂，包含多条case，每条case都需要break结束，注意switch的取值，case取值必须都是具体值
					
			循环结构：while、do...while结构和for、foreach循环
					
      注意while（先判断，在执行） 和 do...while(先执行，在判断)的区别，
			
      for循环注意是流程，
			
      foreach只能遍历容器
			
      其他控制语句：break(跳出所在循环)，continue(结束本次循环继续下次循环)

1. 函数：
			
      函数存在的意义。
			
      函数的定义格式，注意返回值，返回值类型，参数
			
      函数重载：在一个类型中允许存在一个以上的同名函数，参数列表不同（参数个数和参数类型）
      
      
### 第二部分：面对对象（思想）。7—15天
 
1. 面向对象思想是怎么回事，举例。准备例子面试用，

1. 查询MSDN,包含了C#中所有的已经定义好的内容，API,UnityAPI

1. 数组及常见用法
 
	 一维数组：

	 定义数组的格式一：元素类型[] 数组名 = new 元素类型[元素个数或数组长度]

	 定义数组的格式二(两种)：元素类型[] 数组名 = new 元素类型[]{元素, 元素….} 、 元素类型[] 数组名 = {元素, 元素….}

	 使用索引对数组里面的内容进行操作（遍历、求最值、排序、查找）

	 二维数组：注意定义格式。
	 数组是容器，本身就是对象。是引用类型，定义在堆内存中

1. 字符串的操作：

	 进一步深化了面向对象思想，string和stringBuilder对象可以对字符串进行操作，

	 注意string的特性： 不可变性

	 stringBuilder创建可变字符串。

	 注意string和stringBuilder的区别：String就是代表内存中无法被改变的字符串，即不可变性。而StringBuilder提供的则是可变字符串，StringBuilder更加倾向于对字符串的增删查改

1. 状态机的使用

	 程序设计范畴，处理问题的一种可行方法，有了状态机思想，可以解决状态转换及记忆内容问题

	 主要核心就是穿件状态机模型，分析所有的状态以及在每种状态下所有可能出现的可能

1. 类和对象

	 类和对象关系，必须要可以描述类和对象的关系

	 类是具有相同数据结构（属性）和相同操作功能（行为）对象的集合。对象就是符合某种类所产生的一个实例

	 如何创建一个对象使用new关键字。只有对象，才可以使用其内容

1. 属性

	 可以将字段进行封装，是字段更加具有安全性，属性一般是public ，里面需要写逻辑判断的代码

	 定义属性的格式，以及get/set的使用

1. 构造函数 constructor

	 必须名学构造函数的作用1 —— 初始化对象用的，作用2 —— 可以为初始化的对象进行赋值

	 注意构造函数的格式，没有返回值，没有返回值类型。  构造函数可以重载

1. this关键字

	 可以用来区分局部变量和成员变量重名

	 可以用来代表所在函数所属对象的引用，代表本类对象的引用

1. static关键字

	 什么情况下可以用来修饰字段？ 当一个类中的内容需要共享的时候就可以用static修饰，被static修饰的内容优先于对象存在。

	 什么情况下修饰方法？ 参考这个方法是否访问非静态内容，如果要访问非静态，则不能，否则可以的	

	 静态方法和非静态方法的区别总结如下：

		静态方法属于类所有，类实例化前即可使用； 

		非静态方法可以访问类中的任何成员，静态方法只能访问类中的静态成员； 

		因为静态方法在类实例化前就可以使用，而类中的非静态变量必须在实例化之后才能分配内存；    

		static内部只能出现static变量和其他static方法!而且static方法中还不能使用this等关键字，因为它是属于整个类；

		静态方法效率上要比实例化高，静态方法的缺点是不自动进行销毁，而实例化的则可以做销毁； 

		静态方法和静态变量创建后始终使用同一块内存，而使用实例的方式会创建多个内存。

		主要区别：静态方法在创建对象前就可以使用了，非静态方法必须通过new出来的对象调用

	 静态只能访问静态，非静态既能访问静态也可以访问非静态

	 注意共享的举例

1. 继承
 
	 继承是面向对象的三大特征之一，为多态提供了前提

	 必须要知道继承表现形式以及实现继承后的好处

	 注意，当实现继承后，子父类中的成员会出现一定的关系						

1. 抽象类
	 明确抽象类存在的意义以及抽象类的定义 abstract 关键字。一般情况下抽象类中要由抽象函数，可以有普通函数

	 注意抽象类和普通类的区别：
	 1，抽象类不可以被实例化，普通类可以

	 2，抽象类一般要有抽象方法，普通类只有非抽象方法

	 3，抽象类描述事物一般不具体，普通类是具体的

1. 多态

	 面向对象三大特征之一，多态的含义：	一类事物可以在不同情况下表现出来多种的形态

	 方法也有多态；方法重载，重写

	 对象当中的多态，对于父类来说，可以将父类当做其不同的子类来使用，子类既可以当做其本身又能当做父类使用

	 多态在接口中也有所体现，以及非泛型集合类

	 清楚什么时候使用多态，多态的表现形式，

1. 接口

	 interface 接口和抽象类有相似之处，但又有严重不同，

	 接口中都是没有实现的抽象方法，需要其实现类来实现。并实现所有的方法，才能实例化其实现类

	 接口和接口之间可以多继承，

	 一个类可以继承另一个类的同时多实现其他接口，      

### 第三部分：对面向对象的使用 Object 常见集合类，泛型委托事件，字符串处理

1. Object 所有类的基类，知道里面有四个常用方法。

2. 权限修饰符：
	public 公共的，权限最大，可以用来修饰成员和类
	
	private 私有的，权限最小，只能用来修饰成员，如果成员啥都不写，默认是private
	
	protected 受保护的，只有本类及其所在子类才可以访问，只能修饰成员
	
	internal 内部的，可以修饰类及成员，所有程序（项目）中的内容都可以访问，如果类不写修饰符，默认是internal

3. 装箱拆箱
	
	明确装箱拆箱的过程，值类型和引用类型的互相转化，
	
	在装箱中涉及到的动作：堆、拷贝、地址传递
	
	拆箱中涉及到的动作：必须先装箱才能拆箱，
	
	要明确装箱拆箱带来的负面影响
	
	如何避免？1，使用方法重载 ；2，使用泛型

4. 枚举（enum）
	
	里面只需要定义枚举项就可以，注意每一个枚举项都有对应的int类型数字
	
	一般是使用已经封装好的枚举

5. 结构体（struct）
	
	明确结构体和类在定义内容上的区别
	
	明确结构体和类在使用上的区别
	
	明确结构体和类在根本上的区别（类是引用类型，结构体是值类型）
	
	结构体不能继承其他的类。但是可以实现接口

6. 方法的四种参数
	
	值类型：直接将实参的值拷贝传入到方法中
	
	引用类型：直接将实参的地址值传入到方法中
	
	输出型：将具体数据从方法中传递到方法外
	
	数组型： 参数个数不固定，最终形成新数组

7. 常见及各类
	
	常见集合类：ArrayList 、Queue 、 Hashtable 、 sortedList
	
	List<> Dictionary<,> queue<> stack<> Hashset<> LinkedList<>
	
	对于常见集合类，应该明确每一种集合类存储数据的方式，掌握每一个集合类中常见属性及方法
	
	明确泛型集合类的方法

8. 泛型
	
	泛型是C#给提供的一种类型安全机制，可以使得操作类型时统一，可以省去很多麻烦及不必要的错误
	
	麻烦：强制转换，错误。类型转换异常，

9. 委托和事件
	
	委托：可以让我们将方法作为参数进行操作和传递    可以自定义泛型方法、类、接口、委托      
	
	
委托（delegate）, 一个方法（功能）自己不做委托给别人做，

是一种类型，用来封装函数

**定义格式：修饰符  delegate  函数的返回值类型  委托名字 (函数参数列表);**
```C#
public delegate void DeleDemo();//定义一个委托，返回值类型为void，没有参数。

public delegate int DeleInt(int i);//定义一个带返回值的，带参数的委托。
```    

可以定义在类里或者类的外边，根据自己需求

声明委托是，必须向委托中添加函数,使用 += 符号，向委托中注册方法、 使用 -= 符号，删除委托中的方法，可以使用+符号合并委托。
```C#
//声明委托类型
DeleDemo dele = new DeleDemo(Show);//声明委托时，必须要向委托中添加函数。
dele();//类似调用方法
DeleDemo dele = Show;
dele += Show3;//使用+=符号，向委托中注册方法
dele -= Show;//使用-=符号，删除委托中的方法
dele();//调用委托，执行Show方法。


Wangcai wc = new Wangcai();
Buy buy = new Buy(wc.BuyFood);//声明Buy委托，并注册BuyFood方法
buy += wc.BuyWater;
buy += wc.BuyTicket;//向一个委托中注册多个方法的时候，叫多播委托。
buy -= wc.BuyWater;
buy();
Buy buy1 = new Buy(wc.BuyWater);
Buy buy3 = buy + buy1;//使用+符号合并委托。
buy3();
```

委托是一种数据类型（引用类型） 委托明确规定了方法的返回值类型和参数，可以向一个委托中注册多个符合类型的方法，执行委托，会执行所有已注册的方

可以向一个委托中一参数的形式添加声明相同但功能不同的方法， 这样在执行具体委托时，会执行所有方法，委托的出现提高了代码的灵活性和扩展性

可以避免大量的使用逻辑判断语句，相当于 动态给方法赋值

* 弊端：打破了封装性，使程序变得不安全 。
```C#
将委托作为参数，在调用方法时，委托可以接收方法，这样可以直接明确Greeting里面调用的内容，进而省去了判断，使得程序更加易于维护。
public void Greeting(string name, Greeting greeting) {
      greeting(name);
}
```
使用事件可以避免委托的不安全性，事件是对委托的封装


# 事件

想要使用事件，必须有委托，事件属于成员，定义在类中

**定义格式： 权限修饰符  event  委托名字 事件名;**

事件无法从事件所在类的外部直接调用。    向事件中注册方法，在事件所在的类的外部，只能向事件注册方法

事件和委托的区别：
1. 委托可以在所在类的外部直接调用，事件不行，只能在所在的类调用
1. 委托可以直接初始化，而事件无法直接初始化，只能通过+=或-=为事件注册或注销方法

相同点：都可以封装符合其类型的方法。
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      














						
