# 委托

委托（delegate）, 一个方法（功能）自己不做委托给别人做，

是一种类型，用来封装函数

**定义格式：修饰符  delegate  函数的返回值类型  委托名字 (函数参数列表);**
```C#
public delegate void DeleDemo();//定义一个委托，返回值类型为void，没有参数。

public delegate int DeleInt(int i);//定义一个带返回值的，带参数的委托。
```    

可以定义在类里或者类的外边，根据自己需求

声明委托是，必须向委托中添加函数,使用 += 符号，向委托中注册方法、 使用 -= 符号，删除委托中的方法，可以使用+符号合并委托。
```C#
//声明委托类型
DeleDemo dele = new DeleDemo(Show);//声明委托时，必须要向委托中添加函数。
dele();//类似调用方法
DeleDemo dele = Show;
dele += Show3;//使用+=符号，向委托中注册方法
dele -= Show;//使用-=符号，删除委托中的方法
dele();//调用委托，执行Show方法。


Wangcai wc = new Wangcai();
Buy buy = new Buy(wc.BuyFood);//声明Buy委托，并注册BuyFood方法
buy += wc.BuyWater;
buy += wc.BuyTicket;//向一个委托中注册多个方法的时候，叫多播委托。
buy -= wc.BuyWater;
buy();
Buy buy1 = new Buy(wc.BuyWater);
Buy buy3 = buy + buy1;//使用+符号合并委托。
buy3();
```

委托是一种数据类型（引用类型） 委托明确规定了方法的返回值类型和参数，可以向一个委托中注册多个符合类型的方法，执行委托，会执行所有已注册的方

可以向一个委托中一参数的形式添加声明相同但功能不同的方法， 这样在执行具体委托时，会执行所有方法，委托的出现提高了代码的灵活性和扩展性

可以避免大量的使用逻辑判断语句，相当于 动态给方法赋值

* 弊端：打破了封装性，使程序变得不安全 。
```C#
将委托作为参数，在调用方法时，委托可以接收方法，这样可以直接明确Greeting里面调用的内容，进而省去了判断，使得程序更加易于维护。
public void Greeting(string name, Greeting greeting) {
      greeting(name);
}
```
使用事件可以避免委托的不安全性，事件是对委托的封装


# 事件

想要使用事件，必须有委托，事件属于成员，定义在类中

**定义格式： 权限修饰符  event  委托名字 事件名;**

事件无法从事件所在类的外部直接调用。    向事件中注册方法，在事件所在的类的外部，只能向事件注册方法

事件和委托的区别：
1. 委托可以在所在类的外部直接调用，事件不行，只能在所在的类调用
1. 委托可以直接初始化，而事件无法直接初始化，只能通过+=或-=为事件注册或注销方法

相同点：都可以封装符合其类型的方法。







































